(function(){"use strict";const X=Math.pow(10,-9),ut=new Uint8Array([0,10,19,23,27,32]),mt=16,nt=2;function Xt(){const o=new Map,t=16,e=new Float32Array(2);let s=0,n=0,i=0,r=0,l=0,a=0;for(l=1;l<=t;++l)for(s=Math.round(360/l),n=2*Math.PI/l,a=0;a<l;++a)r=s*a,o.has(r)||(i=n*a,e[0]=Math.sin(i),e[1]=Math.cos(i),o.set(r,e.slice()));return o}const Vt=Xt();function Bt(o,t=0){return(1<<o)-1<<t}function ht(o,t,e,s){const n=Bt(s,e);return o&~n|t<<e&n}function $(o,t,e){return o>>>t&Bt(e)}function et(o,t){return $(o,t*mt,mt)}function It(o,t){return o|t<<mt}function N(o,t=0,e=X){return Math.abs(o-t)<e}function V(o,t,e){return Math.abs(2*o-t-e)-Math.abs(t-e)}function O(o,t,e){return(o+t+e)%t}function yt(o,t){return Math.round(o*t/360)}function Nt(o,t,e,s){const n=yt(e.rotation,o),i=yt(s.rotation,o),r=new Uint8Array([e.source+1,s.source+1,n,i,t?1:0]),l=r.length;let a=0,u=0;for(u=0;u<l;++u)a=ht(a,r[u],ut[u],ut[u+1]-ut[u]);return a}function Lt(o,t){return{source:o,rotation:0,memSeg:t,children:[]}}function Q(o){return o<0?-Math.round(Math.abs(o)):Math.round(o)}function Ft(o){return o<0?Math.ceil(o):Math.floor(o)}function Dt(o){const s=new Uint16Array(4);let n=Math.abs(o<<0),i=0;for(i=0;i<4;++i)s[i]=n&65535,n=n>>>16;return s}function gt(o,t){const e=Dt(o),s=Dt(t),n=new Uint32Array(5),i=4294967295;let r=0;for(n[0]=0,n[1]=e[0]*s[0]&i,n[2]=e[1]*s[0]+e[0]*s[1]&i,n[3]=e[2]*s[0]+e[0]*s[2]+e[1]*s[1]&i,n[4]=e[3]*s[3]+e[3]*s[0]+e[2]*s[1]&i,r=4;r>0;--r)n[r]+=n[r-1]>>>16;return n[0]=1+Math.sign(o)*Math.sign(t),n}function Jt(o,t){const e=o.length;let s=0;for(s=0;s<e;++s)if(o[s]!==t[s])return!1;return!0}function bt(o,t,e,s,n){return n?Jt(gt(o,t),gt(e,s)):Ft(o*t)-Ft(e*s)===0}var q=(o=>(o[o.NON_ZERO=1]="NON_ZERO",o[o.POSITIVE=2]="POSITIVE",o[o.NEGATIVE=3]="NEGATIVE",o))(q||{}),j=(o=>(o[o.SUBJECT=0]="SUBJECT",o[o.CLIP=1]="CLIP",o))(j||{}),g=(o=>(o[o.UNION=1]="UNION",o[o.DIFFERENCE=2]="DIFFERENCE",o))(g||{}),A=(o=>(o[o.LEFT=0]="LEFT",o[o.RIGHT=1]="RIGHT",o))(A||{});const D=class D{constructor(t,e=0){this.memSeg=t,this.offset=e}bind(t,e=0){return this.memSeg=t,this.offset=e,this}fromMemSeg(t,e=0,s=0){return this.x=t[s+(e<<1)],this.y=t[s+(e<<1)+1],this}fill(t,e,s=0){t[s+(e<<1)]=this.x,t[s+(e<<1)+1]=this.y}set(t,e){return this.x=t,this.y=e,this}update(t){return this.set(t.x,t.y)}fromClipper(t){return this.set(t.x,t.y)}add(t){return this.x+=t.x,this.y+=t.y,this}sub(t){return this.x-=t.x,this.y-=t.y,this}mul(t){return this.x*=t.x,this.y*=t.y,this}scaleUp(t){return this.x*=t,this.y*=t,this}scaleDown(t){return this.x/=t,this.y/=t,this}max(t){return this.set(Math.max(this.x,t.x),Math.max(this.y,t.y))}min(t){return this.set(Math.min(this.x,t.x),Math.min(this.y,t.y))}rotate(t){const e=Vt.get(t),s=e[0],n=e[1];return this.set(this.x*n-this.y*s,this.x*s+this.y*n)}cross(t){return this.y*t.x-this.x*t.y}dot(t){return this.x*t.x+this.y*t.y}getBetween(t,e){return t.almostEqual(e)||t.almostEqual(this)||this.almostEqual(e)?!1:t.x!==e.x?this.x>t.x==this.x<e.x:this.y>t.y==this.y<e.y}len2(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}len(t){return Math.sqrt(this.len2(t))}normalize(){const t=this.length;return!N(t,1)&&!this.isEmpty&&(this.x=this.x/t,this.y=this.y/t),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}clipperRound(){return this.x=Q(this.x),this.y=Q(this.y),this}normal(){return this.set(this.y,-this.x)}reverse(){return this.set(-this.x,-this.y)}onSegment(t,e){const s=V(this.x,t.x,e.x),n=V(this.y,t.y,e.y);if(N(t.x,e.x)&&N(this.x,t.x))return!N(this.y,e.y)&&!N(this.y,t.y)&&n<0;if(N(t.y,e.y)&&N(this.y,t.y))return!N(this.x,e.x)&&!N(this.x,t.x)&&s<0;if(s>0||n>0||this.almostEqual(t)||this.almostEqual(e))return!1;const i=D.from(this).sub(t),r=D.from(e).sub(t);if(Math.abs(i.cross(r))>X)return!1;const l=i.dot(r);if(l<X)return!1;const a=t.len2(e);return!(l>a||N(l,a))}almostEqual(t,e=X){return N(this.x,t.x,e)&&N(this.y,t.y,e)}interpolateX(t,e){return(t.x-e.x)*(this.y-e.y)/(t.y-e.y)+e.x}interpolateY(t,e){return(t.y-e.y)*(this.x-e.x)/(t.x-e.x)+e.y}export(){return this.memSeg.slice(this.offset,this.offset+2)}get x(){return this.memSeg[this.offset]}set x(t){this.memSeg[this.offset]=t}get y(){return this.memSeg[this.offset+1]}set y(t){this.memSeg[this.offset+1]=t}get length(){return Math.sqrt(this.length2)}get length2(){return this.x*this.x+this.y*this.y}get isEmpty(){return this.x===0&&this.y===0}static horzSegmentsOverlap(t,e,s,n){return t.x>s.x==t.x<n.x||e.x>s.x==e.x<n.x||s.x>t.x==s.x<e.x||n.x>t.x==n.x<e.x||t.x===s.x&&e.x===n.x||t.x===n.x&&e.x===s.x}static slopesEqual(t,e,s,n){return bt(t.y-e.y,e.x-s.x,t.x-e.x,e.y-s.y,n)}static create(t,e){const s=new Float64Array(2);return s[0]=t,s[1]=e,new D(s)}static zero(){return D.create(0,0)}static from(t){return D.create(t.x,t.y)}static lineEquation(t,e){return[e.y-t.y,t.x-e.x,e.x*t.y-t.x*e.y]}static rangeTest(t,e){if(e)(Math.abs(t.x)>D.HIGH_RANGE||Math.abs(t.y)>D.HIGH_RANGE)&&console.warn("Coordinate outside allowed range in rangeTest().");else if(Math.abs(t.x)>D.LOW_RANGE||Math.abs(t.y)>D.LOW_RANGE)return D.rangeTest(t,!0);return e}static pointsAreClose(t,e,s){return D.from(t).len2(e)<=s}};D.LOW_RANGE=47453132,D.HIGH_RANGE=0xfffffffffffff;let p=D;const vt=-9007199254740992;class b{constructor(t=0,e=null,s=null,n=null){this.index=t,this.point=e===null?p.zero():p.from(e),this.next=s,this.prev=n}exclude(){const t=this.prev;return t.next=this.next,this.next.prev=t,t.index=0,t}dispose(){let t=this;for(t.prev.next=null;t!==null;)t=t.next}duplicate(t){const e=new b(this.index,this.point);return t?(e.next=this.next,e.prev=this,this.next.prev=e,this.next=e):(e.prev=this.prev,e.next=this,this.prev.next=e,this.prev=e),e}get pointCount(){let t=0,e=this;do++t,e=e.next;while(e!==this);return t}reverse(){let t=this,e=t,s=null;do s=e.next,e.next=e.prev,e.prev=s,e=s;while(e!==t)}pointIn(t){let e=this,s=e,n=0,i=0,r=0,l=0,a=0,u=0;for(;;){if(i=e.point.x,r=e.point.y,l=e.next.point.x,a=e.next.point.y,a===t.y&&(l===t.x||r===t.y&&l>t.x==i<t.x))return-1;if(r<t.y!=a<t.y){if(i>=t.x)if(l>t.x)n=1-n;else{if(u=(i-t.x)*(a-t.y)-(l-t.x)*(r-t.y),u==0)return-1;u>0==a>r&&(n=1-n)}else if(l>t.x){if(u=(i-t.x)*(a-t.y)-(l-t.x)*(r-t.y),u===0)return-1;u>0==a>r&&(n=1-n)}}if(e=e.next,s==e)break}return n}getBottomPt(){let t=this,e=this.next,s=null;for(;e!==t;)e.point.y>t.point.y?(t=e,s=null):e.point.y==t.point.y&&e.point.x<=t.point.x&&(e.point.x<t.point.x?(s=null,t=e):e.next!==t&&e.prev!==t&&(s=e)),e=e.next;if(s!==null)for(;s!==e;)for(b.firstIsBottomPt(e,s)||(t=s),s=s.next;!s.point.almostEqual(t.point);)s=s.next;return t}static firstIsBottomPt(t,e){let s=t.prev;for(;s.point.almostEqual(t.point)&&s!==t;)s=s.prev;const n=b.getDx(t,s);for(s=t.next;s.point.almostEqual(t.point)&&s!==t;)s=s.next;const i=b.getDx(t,s);for(s=e.prev;s.point.almostEqual(e.point)&&s!==e;)s=s.prev;const r=b.getDx(e,s);for(s=e.next;s.point.almostEqual(e.point)&&s!==e;)s=s.next;const l=b.getDx(e,s),a=Math.max(r,l);return n>=a||i>=a}static joinHorz(t,e,s,n,i,r){const l=t.point.x>e.point.x?A.LEFT:A.RIGHT,a=s.point.x>n.point.x?A.LEFT:A.RIGHT;if(l===a)return!1;if(l===A.RIGHT){for(;t.next.point.x<=i.x&&t.next.point.x>=t.point.x&&t.next.point.y===i.y;)t=t.next;r&&t.point.x!==i.x&&(t=t.next),e=t.duplicate(!r),e.point.almostEqual(i)||(t=e,t.point.update(i),e=t.duplicate(!r))}else{for(;t.next.point.x>=i.x&&t.next.point.x<=t.point.x&&t.next.point.y===i.y;)t=t.next;!r&&t.point.x!==i.x&&(t=t.next),e=t.duplicate(r),e.point.almostEqual(i)||(t=e,t.point.update(i),e=t.duplicate(r))}if(a===A.RIGHT){for(;s.next.point.x<=i.x&&s.next.point.x>=s.point.x&&s.next.point.y===i.y;)s=s.next;r&&s.point.x!==i.x&&(s=s.next),n=s.duplicate(!r),n.point.almostEqual(i)||(s=n,s.point.update(i),n=s.duplicate(!r))}else{for(;s.next.point.x>=i.x&&s.next.point.x<=s.point.x&&s.next.point.y===i.y;)s=s.next;!r&&s.point.x!==i.x&&(s=s.next),n=s.duplicate(r),n.point.almostEqual(i)||(s=n,s.point.update(i),n=s.duplicate(r))}return l===A.RIGHT===r?(t.prev=s,s.next=t,e.next=n,n.prev=e):(t.next=s,s.prev=t,e.prev=n,n.next=e),!0}static getDx(t,e){const s=e.point.y-t.point.y,n=e.point.x-t.point.x,i=s===0?vt:n/s;return Math.abs(i)}}function Wt(o){const t=o.length;if(t<3)return 0;let e=0,s=0,n=0;for(s=0,n=t-1;s<t;++s)e+=(o[n].x+o[s].x)*(o[n].y-o[s].y),n=s;return-e*.5}function ct(o){return Math.abs(Wt(o))}function Zt(o,t,e){const s=p.lineEquation(e,t),n=s[0]*o.x+s[1]*o.y-s[2];return n*n/(s[0]*s[0]+s[1]*s[1])}function Kt(o,t,e,s){return Zt(t,o,e)<s}function At(o,t){let e=o.length;const s=new Array(e);let n=0;for(n=0;n<e;++n)s[n]=new b(0,o[n]);for(n=0;n<e;++n)s[n].next=s[O(n,e,1)],s[n].next.prev=s[n];const i=t*t;let r=s[0];for(;r.index===0&&r.next!=r.prev;)p.pointsAreClose(r.point,r.prev.point,i)?(r=r.exclude(),--e):p.pointsAreClose(r.prev.point,r.next.point,i)?(r.next.exclude(),r=r.exclude(),e-=2):Kt(r.prev.point,r.point,r.next.point,i)?(r=r.exclude(),--e):(r.index=1,r=r.next);if(e<3)return[];const l=new Array(e);for(n=0;n<e;++n)l[n]=p.from(r.point),r=r.next;return l}function $t(o,t){const e=o.length,s=new Array(e);let n=0;for(n=0;n<e;++n)s[n]=At(o[n],t);return s}function Y(o){try{throw new Error(o)}catch(t){console.warn(t.message)}}class J{constructor(t=0,e=null){this.Y=t,this.Next=e}static insert(t,e){if(e===null)return new J(t);if(t>e.Y)return new J(t,e);let s=e;for(;s.Next!==null&&t<=s.Next.Y;)s=s.Next;return t!==s.Y&&(s.Next=new J(t,s.Next)),e}}class Ht{constructor(t=0,e=null,s=null,n=null){this.y=0,this.y=t,this.leftBound=e,this.rightBound=s,this.next=n}insert(t){if(t===null)return this;if(this.y>=t.y)return this.next=t,this;let e=t;for(;e.next!==null&&this.y<e.next.y;)e=e.next;return this.next=e.next,e.next=this,t}reset(){let t=this;for(;t!=null;)t.leftBound!==null&&t.leftBound.reset(A.LEFT),t.rightBound!==null&&t.rightBound.reset(A.RIGHT),t=t.next}getScanbeam(){let t=this,e=null;for(;t!==null;)e=J.insert(t.y,e),t=t.next;return e}}const it=class it{constructor(){this.Bot=p.zero(),this.Curr=p.zero(),this.Top=p.zero(),this.Delta=p.zero(),this.Dx=0,this.PolyTyp=j.SUBJECT,this.Side=A.LEFT,this.WindDelta=0,this.WindCnt=0,this.WindCnt2=0,this.index=0,this.Next=null,this.Prev=null,this.NextInLML=null,this.NextInAEL=null,this.PrevInAEL=null,this.NextInSEL=null,this.PrevInSEL=null}init(t,e,s){this.Next=t,this.Prev=e,this.Curr.update(s),this.unassign()}initFromPolyType(t){this.Curr.y>=this.Next.Curr.y?(this.Bot.update(this.Curr),this.Top.update(this.Next.Curr)):(this.Top.update(this.Curr),this.Bot.update(this.Next.Curr)),this.setDx(),this.PolyTyp=t}remove(){const t=this.Next;return this.Prev.Next=this.Next,this.Next.Prev=this.Prev,this.Prev=null,this.Next=null,t}reverseHorizontal(){const t=this.Top.x;this.Top.x=this.Bot.x,this.Bot.x=t}findNextLocMin(){let t=this,e=null;for(;;){for(;!t.Bot.almostEqual(t.Prev.Bot)||t.Curr.almostEqual(t.Top);)t=t.Next;if(!t.isDxHorizontal&&!t.Prev.isDxHorizontal)break;for(;t.Prev.isDxHorizontal;)t=t.Prev;for(e=t;t.isDxHorizontal;)t=t.Next;if(t.Top.y!==t.Prev.Bot.y){e.Prev.Bot.x<t.Bot.x&&(t=e);break}}return t}setDx(){this.Delta.update(this.Top).sub(this.Bot),this.Dx=this.Delta.y===0?vt:this.Delta.x/this.Delta.y}reset(t){this.Curr.update(this.Bot),this.Side=t,this.unassign()}copyAELToSEL(){return this.PrevInSEL=this.PrevInAEL,this.NextInSEL=this.NextInAEL,this.NextInAEL}topX(t){return t===this.Top.y?this.Top.x:this.Bot.x+Q(this.Dx*(t-this.Bot.y))}deleteFromSEL(t){if(this.PrevInSEL===null&&this.NextInSEL===null&&this!==t)return t;let e=t;return this.PrevInSEL!==null?this.PrevInSEL.NextInSEL=this.NextInSEL:e=this.NextInSEL,this.NextInSEL!==null&&(this.NextInSEL.PrevInSEL=this.PrevInSEL),this.NextInSEL=null,this.PrevInSEL=null,e}deleteFromAEL(t){if(this.PrevInAEL===null&&this.NextInAEL===null&&this!==t)return t;let e=t;return this.PrevInAEL!==null?this.PrevInAEL.NextInAEL=this.NextInAEL:e=this.NextInAEL,this.NextInAEL!==null&&(this.NextInAEL.PrevInAEL=this.PrevInAEL),this.NextInAEL=null,this.PrevInAEL=null,e}getIntermediate(t){return this.Top.y===t&&this.NextInLML!==null}get isFilled(){return this.isAssigned&&!this.isWindDeletaEmpty}get isHorizontal(){return this.Delta.y===0}get isWindDeletaEmpty(){return this.WindDelta===0}get isDxHorizontal(){return this.Dx===vt}get maximaPair(){let t=null;return this.Next!==null&&this.Next.Top.almostEqual(this.Top)&&this.Next.NextInLML===null?t=this.Next:this.Prev!==null&&this.Prev.Top.almostEqual(this.Top)&&this.Prev.NextInLML===null&&(t=this.Prev),t!==null&&t.NextInAEL===t.PrevInAEL&&!t.isHorizontal?null:t}getMaxima(t){return this.Top.y===t&&this.NextInLML===null}getContributing(t,e){const s=t===g.DIFFERENCE&&this.PolyTyp===j.CLIP;switch(e){case q.NON_ZERO:return Math.abs(this.WindCnt)===1&&s!==(this.WindCnt2===0);case q.POSITIVE:return this.WindCnt===1&&s!==this.WindCnt2<=0;default:return this.WindCnt===-1&&s!==this.WindCnt2>=0}}insertsBefore(t){return this.Curr.x===t.Curr.x?this.Top.y>t.Top.y?this.Top.x<t.topX(this.Top.y):t.Top.x>this.topX(t.Top.y):this.Curr.x<t.Curr.x}addEdgeToSEL(t){return this.PrevInSEL=null,this.NextInSEL=t,t!==null&&(t.PrevInSEL=this),this}insertEdgeIntoAEL(t,e=null){if(t===null)return this.PrevInAEL=null,this.NextInAEL=null,this;if(e===null&&this.insertsBefore(t))return this.PrevInAEL=null,this.NextInAEL=t,t.PrevInAEL=this,this;let s=e===null?t:e;for(;s.NextInAEL!==null&&!this.insertsBefore(s.NextInAEL);)s=s.NextInAEL;return this.NextInAEL=s.NextInAEL,s.NextInAEL!==null&&(s.NextInAEL.PrevInAEL=this),this.PrevInAEL=s,s.NextInAEL=this,t}getNextInAEL(t){return t===A.RIGHT?this.NextInAEL:this.PrevInAEL}unassign(){this.index=it.UNASSIGNED}get horzDirection(){return new Float64Array(this.Bot.x<this.Top.x?[A.RIGHT,this.Bot.x,this.Top.x]:[A.LEFT,this.Top.x,this.Bot.x])}get isAssigned(){return this.index!==it.UNASSIGNED}setWindingCount(t,e){let s=this.PrevInAEL;for(;s!==null&&(s.PolyTyp!==this.PolyTyp||s.isWindDeletaEmpty);)s=s.PrevInAEL;for(s===null?(this.WindCnt=this.isWindDeletaEmpty?1:this.WindDelta,this.WindCnt2=0,s=t):this.isWindDeletaEmpty&&e!==g.UNION?(this.WindCnt=1,this.WindCnt2=s.WindCnt2,s=s.NextInAEL):(s.WindCnt*s.WindDelta<0?Math.abs(s.WindCnt)>1?this.WindCnt=s.WindDelta*this.WindDelta<0?s.WindCnt:s.WindCnt+this.WindDelta:this.WindCnt=this.isWindDeletaEmpty?1:this.WindDelta:this.isWindDeletaEmpty?this.WindCnt=s.WindCnt<0?s.WindCnt-1:s.WindCnt+1:this.WindCnt=s.WindDelta*this.WindDelta<0?s.WindCnt:s.WindCnt+this.WindDelta,this.WindCnt2=s.WindCnt2,s=s.NextInAEL);s!==this;)this.WindCnt2+=s.WindDelta,s=s.NextInAEL}static intersectPoint(t,e,s,n){if(it.slopesEqual(t,e,n)||t.Dx===e.Dx){const i=e.Bot.y>t.Bot.y?e.Bot:t.Bot;return s.update(i),!1}if(t.Delta.x===0)s.set(t.Bot.x,e.isHorizontal?e.Bot.y:Q((t.Bot.x-e.Bot.x)/e.Dx+e.Bot.y));else if(e.Delta.x===0)s.set(e.Bot.x,t.isHorizontal?t.Bot.y:Q((e.Bot.x-t.Bot.x)/t.Dx+t.Bot.y));else{const i=t.Bot.x-t.Bot.y*t.Dx,r=e.Bot.x-e.Bot.y*e.Dx,l=(r-i)/(t.Dx-e.Dx);s.set(Math.abs(t.Dx)<Math.abs(e.Dx)?Q(t.Dx*l+i):Q(e.Dx*l+r),Q(l))}if(s.y<t.Top.y||s.y<e.Top.y){if(t.Top.y>e.Top.y)return s.set(e.topX(t.Top.y),t.Top.y),s.x<t.Top.x;s.set(Math.abs(t.Dx)<Math.abs(e.Dx)?t.topX(s.y):e.topX(s.y),e.Top.y)}return!0}static slopesEqual(t,e,s){return bt(t.Delta.y,e.Delta.x,t.Delta.x,e.Delta.y,s)}static swapPositionsInAEL(t,e){if(t.NextInAEL===t.PrevInAEL||e.NextInAEL===e.PrevInAEL)return!1;let s=null,n=null;return t.NextInAEL===e?(n=e.NextInAEL,n!==null&&(n.PrevInAEL=t),s=t.PrevInAEL,s!==null&&(s.NextInAEL=e),e.PrevInAEL=s,e.NextInAEL=t,t.PrevInAEL=e,t.NextInAEL=n,!0):e.NextInAEL===t?(n=t.NextInAEL,n!==null&&(n.PrevInAEL=e),s=e.PrevInAEL,s!==null&&(s.NextInAEL=t),t.PrevInAEL=s,t.NextInAEL=e,e.PrevInAEL=t,e.NextInAEL=n,!0):(n=t.NextInAEL,s=t.PrevInAEL,t.NextInAEL=e.NextInAEL,t.NextInAEL!==null&&(t.NextInAEL.PrevInAEL=t),t.PrevInAEL=e.PrevInAEL,t.PrevInAEL!==null&&(t.PrevInAEL.NextInAEL=t),e.NextInAEL=n,e.NextInAEL!==null&&(e.NextInAEL.PrevInAEL=e),e.PrevInAEL=s,e.PrevInAEL!==null&&(e.PrevInAEL.NextInAEL=e),!0)}static swapPositionsInSEL(t,e){if(t.NextInSEL===null&&t.PrevInSEL===null||e.NextInSEL===null&&e.PrevInSEL===null)return!1;let s=null,n=null;return t.NextInSEL===e?(n=e.NextInSEL,n!==null&&(n.PrevInSEL=t),s=t.PrevInSEL,s!==null&&(s.NextInSEL=e),e.PrevInSEL=s,e.NextInSEL=t,t.PrevInSEL=e,t.NextInSEL=n,!0):e.NextInSEL===t?(n=t.NextInSEL,n!==null&&(n.PrevInSEL=e),s=e.PrevInSEL,s!==null&&(s.NextInSEL=t),t.PrevInSEL=s,t.NextInSEL=e,e.PrevInSEL=t,e.NextInSEL=n,!0):(n=t.NextInSEL,s=t.PrevInSEL,t.NextInSEL=e.NextInSEL,t.NextInSEL!==null&&(t.NextInSEL.PrevInSEL=t),t.PrevInSEL=e.PrevInSEL,t.PrevInSEL!==null&&(t.PrevInSEL.NextInSEL=t),e.NextInSEL=n,e.NextInSEL!==null&&(e.NextInSEL.PrevInSEL=e),e.PrevInSEL=s,e.PrevInSEL!==null&&(e.PrevInSEL.NextInSEL=e),!0)}static swapSides(t,e){const s=t.Side;t.Side=e.Side,e.Side=s}static swapPolyIndexes(t,e){const s=t.index;t.index=e.index,e.index=s}};it.UNASSIGNED=-1;let w=it;class Qt{constructor(){this.minimaList=null,this.isUseFullRange=!1,this.currentLM=null}addPath(t,e){let s=t.length-1;for(;s>0&&(t[s].almostEqual(t[0])||t[s].almostEqual(t[s-1]));)--s;if(s<2)return!1;const n=[];let i=0;for(i=0;i<=s;++i)n.push(new w);for(n[1].Curr.update(t[1]),this.isUseFullRange=p.rangeTest(t[0],this.isUseFullRange),this.isUseFullRange=p.rangeTest(t[s],this.isUseFullRange),n[0].init(n[1],n[s],t[0]),n[s].init(n[0],n[s-1],t[s]),i=s-1;i>=1;--i)this.isUseFullRange=p.rangeTest(t[i],this.isUseFullRange),n[i].init(n[i+1],n[i-1],t[i]);let r=n[0],l=r,a=r;for(;;){if(l.Curr.almostEqual(l.Next.Curr)){if(l===l.Next)break;l===r&&(r=l.Next),l=l.remove(),a=l;continue}if(l.Prev===l.Next)break;if(p.slopesEqual(l.Prev.Curr,l.Curr,l.Next.Curr,this.isUseFullRange)){l===r&&(r=l.Next),l=l.remove(),l=l.Prev,a=l;continue}if(l=l.Next,l===a)break}if(l.Prev===l.Next)return!1;l=r;let u=!0;do l.initFromPolyType(e),l=l.Next,u&&l.Curr.y!==r.Curr.y&&(u=!1);while(l!==r);if(u)return!1;let h=!1,c=null;for(;l=l.findNextLocMin(),l!==c;){c===null&&(c=l),h=l.Dx>=l.Prev.Dx;const x=h?new Ht(l.Bot.y,l,l.Prev):new Ht(l.Bot.y,l.Prev,l);x.leftBound.Side=A.LEFT,x.rightBound.Side=A.RIGHT,x.leftBound.WindDelta=x.leftBound.Next===x.rightBound?-1:1,x.rightBound.WindDelta=-x.leftBound.WindDelta,l=this.ProcessBound(x.leftBound,h);const f=this.ProcessBound(x.rightBound,!h);this.minimaList=x.insert(this.minimaList),h||(l=f)}return!0}addPaths(t,e){const s=t.length;let n=!1,i=0;for(i=0;i<s;++i)this.addPath(t[i],e)&&(n=!0);return n}ProcessBound(t,e){let s=t,n=t,i=null;if(t.isDxHorizontal){const r=e?t.Prev.Bot.x:t.Next.Bot.x;t.Bot.x!==r&&t.reverseHorizontal()}if(e){for(;n.Top.y===n.Next.Bot.y;)n=n.Next;if(n.isDxHorizontal){for(i=n;i.Prev.isDxHorizontal;)i=i.Prev;i.Prev.Top.x===n.Next.Top.x?e||(n=i.Prev):i.Prev.Top.x>n.Next.Top.x&&(n=i.Prev)}for(;t!==n;)t.NextInLML=t.Next,t.isDxHorizontal&&t!==s&&t.Bot.x!==t.Prev.Top.x&&t.reverseHorizontal(),t=t.Next;t.isDxHorizontal&&t!==s&&t.Bot.x!==t.Prev.Top.x&&t.reverseHorizontal(),n=n.Next}else{for(;n.Top.y===n.Prev.Bot.y;)n=n.Prev;if(n.isDxHorizontal){for(i=n;i.Next.isDxHorizontal;)i=i.Next;i.Next.Top.x===n.Prev.Top.x?e||(n=i.Next):i.Next.Top.x>n.Prev.Top.x&&(n=i.Next)}for(;t!==n;)t.NextInLML=t.Prev,t.isDxHorizontal&&t!==s&&t.Bot.x!==t.Next.Top.x&&t.reverseHorizontal(),t=t.Prev;t.isDxHorizontal&&t!==s&&t.Bot.x!==t.Next.Top.x&&t.reverseHorizontal(),n=n.Prev}return n}reset(){this.currentLM=this.minimaList,this.currentLM!==null&&this.minimaList.reset()}}class Rt{constructor(t=null,e=null,s=null){this.Edge1=t,this.Edge2=e,this.Pt=s===null?p.zero():p.from(s)}get edgesAdjacent(){return this.Edge1.NextInSEL===this.Edge2||this.Edge1.PrevInSEL===this.Edge2}static sort(t,e){return e.Pt.y-t.Pt.y}}class y{constructor(t=0,e=!1,s=null){this.Idx=t,this.IsHole=!1,this.IsOpen=e,this.FirstLeft=null,this.Pts=s,this.BottomPt=null}fixupOutPolygon(t,e){this.BottomPt=null;let s=null,n=this.Pts;for(;;){if(n!==null&&(n.prev===n||n.prev===n.next)){n.dispose(),this.Pts=null;return}if(n.point.almostEqual(n.next.point)||n.point.almostEqual(n.prev.point)||p.slopesEqual(n.prev.point,n.point,n.next.point,e)&&(!t||!n.point.getBetween(n.prev.point,n.next.point))){s=null,n.prev.next=n.next,n.next.prev=n.prev,n=n.prev;continue}if(n==s)break;s===null&&(s=n),n=n.next}this.Pts=n}reversePts(){this.Pts!==null&&this.Pts.reverse()}dispose(){this.Pts!==null&&this.Pts.dispose()}export(){const t=this.pointCount;if(t<2)return null;const e=new Array(t);let s=this.Pts.prev,n=0;for(n=0;n<t;++n)e[n]=s.point,s=s.prev;return e}joinCommonEdges(t,e){return t.containsPoly(this)?(this.IsHole=!t.IsHole,this.FirstLeft=t,this.IsHole!==e==this.area>0&&this.Pts.reverse(),!0):!1}updateOutPtIdxs(){let t=this.Pts;do t.index=this.Idx,t=t.prev;while(t!==this.Pts)}containsPoly(t){let e=t.Pts,s=0;do{if(s=this.Pts.pointIn(e.point),s>=0)return s!==0;e=e.next}while(e!==t.Pts);return!0}get pointCount(){return this.Pts!==null&&this.Pts.prev!==null?this.Pts.prev.pointCount:0}get isEmpty(){return this.Pts===null||this.IsOpen}get area(){if(this.Pts==null)return 0;let t=this.Pts,e=0;do e=e+(t.prev.point.x+t.point.x)*(t.prev.point.y-t.point.y),t=t.next;while(t!=this.Pts);return e*.5}setHoleState(t,e){let s=!1,n=t.PrevInAEL;for(;n!==null;)n.isAssigned&&!n.isWindDeletaEmpty&&(s=!s,this.FirstLeft===null&&(this.FirstLeft=e[n.index])),n=n.PrevInAEL;s&&(this.IsHole=!0)}simplify(t,e){let s=null,n=null,i=null,r=null;do{for(n=t.next;n!==this.Pts;)t.point.almostEqual(n.point)&&n.next!=t&&n.prev!=t&&(i=t.prev,r=n.prev,t.prev=r,r.next=t,n.prev=i,i.next=n,this.Pts=t,s=y.create(e),s.Pts=n,s.updateOutPtIdxs(),this.containsPoly(s)?(s.IsHole=!this.IsHole,s.FirstLeft=this):s.containsPoly(this)?(s.IsHole=this.IsHole,this.IsHole=!s.IsHole,s.FirstLeft=this.FirstLeft,this.FirstLeft=s):(s.IsHole=this.IsHole,s.FirstLeft=this.FirstLeft),n=t),n=n.next;t=t.next}while(t!=this.Pts)}static param1RightOfParam2(t,e){do if(t=t.FirstLeft,t==e)return!0;while(t!==null);return!1}static parseFirstLeft(t){for(;t!=null&&t.Pts==null;)t=t.FirstLeft;return t}static getLowermostRec(t,e){t.BottomPt===null&&(t.BottomPt=t.Pts.getBottomPt()),e.BottomPt===null&&(e.BottomPt=e.Pts.getBottomPt());const s=t.BottomPt,n=e.BottomPt;switch(!0){case s.point.y>n.point.y:return t;case s.point.y<n.point.y:return e;case s.point.x<n.point.x:return t;case s.point.x>n.point.x:return e;case s.next===s:return e;case n.next===n:return t;case b.firstIsBottomPt(s,n):return t;default:return e}}static addOutPt(t,e,s){const n=e.Side===A.LEFT;let i=null,r=null;if(!e.isAssigned)return r=new b(0,s),i=y.create(t,e.isWindDeletaEmpty,r),r.index=i.Idx,r.next=r,r.prev=r,i.IsOpen||i.setHoleState(e,t),e.index=i.Idx,r;i=t[e.index];const l=i.Pts;return n&&s.almostEqual(l.point)?l:!n&&s.almostEqual(l.prev.point)?l.prev:(r=new b(i.Idx,s,l,l.prev),r.prev.next=r,l.prev=r,n&&(i.Pts=r),r)}static getOutRec(t,e){let s=t[e];for(;s!==t[s.Idx];)s=t[s.Idx];return s}static getHoleStateRec(t,e){switch(!0){case y.param1RightOfParam2(t,e):return e;case y.param1RightOfParam2(e,t):return t;default:return y.getLowermostRec(t,e)}}static addLocalMaxPoly(t,e,s,n,i){if(y.addOutPt(t,e,n),s.isWindDeletaEmpty&&y.addOutPt(t,s,n),e.index===s.index){e.unassign(),s.unassign();return}const r=e.index<s.index?e:s,l=e.index<s.index?s:e,a=t[r.index],u=t[l.index],h=y.getHoleStateRec(a,u),c=a.Pts,x=c.prev,f=u.Pts,E=f.prev;let d;r.Side===A.LEFT?(l.Side===A.LEFT?(f.reverse(),f.next=c,c.prev=f,x.next=E,E.prev=x,a.Pts=E):(E.next=c,c.prev=E,f.prev=x,x.next=f,a.Pts=f),d=A.LEFT):(l.Side===A.RIGHT?(f.reverse(),x.next=E,E.prev=x,f.next=c,c.prev=f):(x.next=f,f.prev=x,c.prev=E,E.next=c),d=A.RIGHT),a.BottomPt=null,h===u&&(u.FirstLeft!==a&&(a.FirstLeft=u.FirstLeft),a.IsHole=u.IsHole),u.Pts=null,u.BottomPt=null,u.FirstLeft=a;const m=r.index,L=l.index;r.unassign(),l.unassign();let I=i;for(;I!==null;){if(I.index===L){I.index=m,I.Side=d;break}I=I.NextInAEL}u.Idx=a.Idx}static create(t,e=!1,s=null){const n=new y(t.length,e,s);return t.push(n),n}}class U{constructor(t=null,e=null,s=null){this.OutPt1=t,this.OutPt2=e,this.OffPt=s===null?p.zero():p.from(s)}joinPoints(t,e){let s=this.OutPt1,n=this.OutPt2,i=new b,r=new b;const l=this.OutPt1.point.y===this.OffPt.y;if(l&&this.OffPt.almostEqual(this.OutPt1.point)&&this.OffPt.almostEqual(this.OutPt2.point)){for(i=this.OutPt1.next;i!==s&&i.point.almostEqual(this.OffPt);)i=i.next;const a=i.point.y>this.OffPt.y;for(r=this.OutPt2.next;r!==n&&r.point.almostEqual(this.OffPt);)r=r.next;const u=r.point.y>this.OffPt.y;return a===u?!1:(a?(i=s.duplicate(!1),r=n.duplicate(!0),s.prev=n,n.next=s,i.next=r,r.prev=i,this.OutPt1=s,this.OutPt2=i):(i=s.duplicate(!0),r=n.duplicate(!1),s.next=n,n.prev=s,i.prev=r,r.next=i,this.OutPt1=s,this.OutPt2=i),!0)}else if(l){for(i=s;s.prev.point.y===s.point.y&&s.prev!==i&&s.prev!==n;)s=s.prev;for(;i.next.point.y===i.point.y&&i.next!==s&&i.next!==n;)i=i.next;if(i.next===s||i.next===n)return!1;for(r=n;n.prev.point.y===n.point.y&&n.prev!==r&&n.prev!==i;)n=n.prev;for(;r.next.point.y===r.point.y&&r.next!==n&&r.next!==s;)r=r.next;if(r.next===n||r.next===s)return!1;const a=U.getOverlap(s.point.x,i.point.x,n.point.x,r.point.x);if(!(a.x<a.y))return!1;const h=p.zero();let c=!1;return s.point.x>=a.x&&s.point.x<=a.y?(h.update(s.point),c=s.point.x>i.point.x):n.point.x>=a.x&&n.point.x<=a.y?(h.update(n.point),c=n.point.x>r.point.x):i.point.x>=a.x&&i.point.x<=a.y?(h.update(i.point),c=i.point.x>s.point.x):(h.update(r.point),c=r.point.x>n.point.x),this.OutPt1=s,this.OutPt2=n,b.joinHorz(s,i,n,r,h,c)}else{for(i=s.next;i.point.almostEqual(s.point)&&i!==s;)i=i.next;const a=i.point.y>s.point.y||!p.slopesEqual(s.point,i.point,this.OffPt,e);if(a){for(i=s.prev;i.point.almostEqual(s.point)&&i!==s;)i=i.prev;if(i.point.y>s.point.y||!p.slopesEqual(s.point,i.point,this.OffPt,e))return!1}for(r=n.next;r.point.almostEqual(n.point)&&r!==n;)r=r.next;const u=r.point.y>n.point.y||!p.slopesEqual(n.point,r.point,this.OffPt,e);if(u){for(r=n.prev;r.point.almostEqual(n.point)&&r!==n;)r=r.prev;if(r.point.y>n.point.y||!p.slopesEqual(n.point,r.point,this.OffPt,e))return!1}return i===s||r===n||i===r||t&&a===u?!1:(a?(i=s.duplicate(!1),r=n.duplicate(!0),s.prev=n,n.next=s,i.next=r,r.prev=i,this.OutPt1=s,this.OutPt2=i):(i=s.duplicate(!0),r=n.duplicate(!1),s.next=n,n.prev=s,i.prev=r,r.next=i,this.OutPt1=s,this.OutPt2=i),!0)}}joinCommonEdges(t,e,s){let n=y.getOutRec(t,this.OutPt1.index),i=y.getOutRec(t,this.OutPt2.index);if(n.Pts===null||i.Pts===null||!this.joinPoints(n===i,e))return;if(n===i){n.Pts=this.OutPt1,n.BottomPt=null,i=y.create(t),i.Pts=this.OutPt2,i.updateOutPtIdxs(),i.joinCommonEdges(i,s)||(i.IsHole=n.IsHole,i.FirstLeft=n.FirstLeft,n.joinCommonEdges(i,s));return}const r=y.getHoleStateRec(n,i);i.Pts=null,i.BottomPt=null,i.Idx=n.Idx,n.IsHole=r.IsHole,r===i&&(n.FirstLeft=i.FirstLeft),i.FirstLeft=n}static getOverlap(t,e,s,n){return t<e?s<n?p.create(Math.max(t,s),Math.min(e,n)):p.create(Math.max(t,n),Math.min(e,s)):s<n?p.create(Math.max(e,s),Math.min(t,n)):p.create(Math.max(e,n),Math.min(t,s))}}class ft extends Qt{constructor(){super(...arguments),this.clipType=g.UNION,this.fillType=q.NON_ZERO,this.scanbeam=null,this.activeEdges=null,this.sortedEdges=null,this.intersections=[],this.isExecuteLocked=!1,this.polyOuts=[],this.joins=[],this.ghostJoins=[],this.ReverseSolution=!1,this.StrictlySimple=!1}execute(t,e,s){if(this.isExecuteLocked)return!1;this.isExecuteLocked=!0,this.fillType=s,this.clipType=t,e.length=0;let n=!1;try{n=this.executeInternal(),n&&this.buildResult(e)}finally{this.disposeAllPolyPts(),this.isExecuteLocked=!1}return n}executeInternal(){try{if(this.reset(),this.currentLM===null)return!1;let t=0,e=null,s=0,n=this.popScanbeam(),i=0;do{if(this.insertLocalMinimaIntoAEL(n),this.ghostJoins=[],this.processHorizontals(!1),this.scanbeam===null)break;if(i=this.popScanbeam(),!this.processIntersections(n,i))return!1;this.processEdgesAtTopOfScanbeam(i),n=i}while(this.scanbeam!==null||this.currentLM!==null);for(s=this.polyOuts.length,t=0;t<s;++t)e=this.polyOuts[t],!e.isEmpty&&e.IsHole!==this.ReverseSolution==e.area>0&&e.reversePts();const r=this.joins.length;for(t=0;t<r;++t)this.joins[t].joinCommonEdges(this.polyOuts,this.isUseFullRange,this.ReverseSolution);for(s=this.polyOuts.length,t=0;t<s;++t)e=this.polyOuts[t],e.isEmpty||e.fixupOutPolygon(!1,this.isUseFullRange);return this.StrictlySimple&&this.doSimplePolygons(),!0}finally{this.joins=[],this.ghostJoins=[]}}processEdgesAtTopOfScanbeam(t){let e=this.activeEdges,s=null,n=!1,i=null,r=null;for(;e!==null;)n=e.getMaxima(t),n&&(s=e.maximaPair,n=s===null||!s.isHorizontal),n?(s=e.PrevInAEL,this.DoMaxima(e),e=s===null?this.activeEdges:s.NextInAEL):(e.getIntermediate(t)&&e.NextInLML.isHorizontal?(e=this.updateEdgeIntoAEL(e),e.isAssigned&&y.addOutPt(this.polyOuts,e,e.Bot),this.sortedEdges=e.addEdgeToSEL(this.sortedEdges)):e.Curr.set(e.topX(t),t),this.StrictlySimple&&(s=e.PrevInAEL,e.isFilled&&s!==null&&s.isFilled&&s.Curr.x===e.Curr.x&&(i=y.addOutPt(this.polyOuts,s,e.Curr),r=y.addOutPt(this.polyOuts,e,e.Curr),this.joins.push(new U(i,r,e.Curr)))),e=e.NextInAEL);for(this.processHorizontals(!0),e=this.activeEdges;e!==null;){if(e.getIntermediate(t)){i=e.isAssigned?y.addOutPt(this.polyOuts,e,e.Top):null,e=this.updateEdgeIntoAEL(e);const l=e.PrevInAEL,a=e.NextInAEL;i!==null&&l!==null&&l.Curr.almostEqual(e.Bot)&&l.isFilled&&l.Curr.y>l.Top.y&&w.slopesEqual(e,l,this.isUseFullRange)&&!e.isWindDeletaEmpty?(r=y.addOutPt(this.polyOuts,l,e.Bot),this.joins.push(new U(i,r,e.Top))):i!==null&&a!==null&&a.Curr.almostEqual(e.Bot)&&a.isFilled&&a.Curr.y>a.Top.y&&w.slopesEqual(e,a,this.isUseFullRange)&&!e.isWindDeletaEmpty&&(r=y.addOutPt(this.polyOuts,a,e.Bot),this.joins.push(new U(i,r,e.Top)))}e=e.NextInAEL}}DoMaxima(t){const e=t.maximaPair;if(e===null){t.isAssigned&&y.addOutPt(this.polyOuts,t,t.Top),this.activeEdges=t.deleteFromAEL(this.activeEdges);return}let s=t.NextInAEL;for(;s!==null&&s!==e;)this.intersectEdges(t,s,t.Top,!0),this.SwapPositionsInAEL(t,s),s=t.NextInAEL;!t.isAssigned&&!e.isAssigned?(this.activeEdges=t.deleteFromAEL(this.activeEdges),this.activeEdges=e.deleteFromAEL(this.activeEdges)):t.isAssigned&&e.isAssigned?this.intersectEdges(t,e,t.Top,!1):t.isWindDeletaEmpty?(t.isAssigned&&(y.addOutPt(this.polyOuts,t,t.Top),t.unassign()),this.activeEdges=t.deleteFromAEL(this.activeEdges),e.isAssigned&&(y.addOutPt(this.polyOuts,e,t.Top),e.unassign()),this.activeEdges=e.deleteFromAEL(this.activeEdges)):Y("DoMaxima error")}insertLocalMinimaIntoAEL(t){let e=null,s=null,n=null;for(;this.currentLM!==null&&this.currentLM.y===t;)if(e=this.currentLM.leftBound,s=this.currentLM.rightBound,n=null,this.currentLM!==null&&(this.currentLM=this.currentLM.next),e===null?(this.activeEdges=s.insertEdgeIntoAEL(this.activeEdges),s.setWindingCount(this.activeEdges,this.clipType),s.getContributing(this.clipType,this.fillType)&&(n=y.addOutPt(this.polyOuts,s,s.Bot))):s===null?(this.activeEdges=e.insertEdgeIntoAEL(this.activeEdges),e.setWindingCount(this.activeEdges,this.clipType),e.getContributing(this.clipType,this.fillType)&&(n=y.addOutPt(this.polyOuts,e,e.Bot)),this.scanbeam=J.insert(e.Top.y,this.scanbeam)):(this.activeEdges=e.insertEdgeIntoAEL(this.activeEdges),this.activeEdges=s.insertEdgeIntoAEL(this.activeEdges,e),e.setWindingCount(this.activeEdges,this.clipType),s.WindCnt=e.WindCnt,s.WindCnt2=e.WindCnt2,e.getContributing(this.clipType,this.fillType)&&(n=this.AddLocalMinPoly(e,s,e.Bot)),this.scanbeam=J.insert(e.Top.y,this.scanbeam)),s!==null&&(s.isHorizontal?this.sortedEdges=s.addEdgeToSEL(this.sortedEdges):this.scanbeam=J.insert(s.Top.y,this.scanbeam)),!(e===null||s===null)){if(n!==null&&s.isHorizontal&&this.ghostJoins.length>0&&!s.isWindDeletaEmpty){const i=this.ghostJoins.length;let r=0,l=null;for(r=0;r<i;++r)l=this.ghostJoins[r],p.horzSegmentsOverlap(l.OutPt1.point,l.OffPt,s.Bot,s.Top)&&this.joins.push(new U(l.OutPt1,n,l.OffPt))}if(e.isFilled&&e.PrevInAEL!==null&&e.PrevInAEL.Curr.x===e.Bot.x&&e.PrevInAEL.isFilled&&w.slopesEqual(e.PrevInAEL,e,this.isUseFullRange)){const i=y.addOutPt(this.polyOuts,e.PrevInAEL,e.Bot);this.joins.push(new U(n,i,e.Top))}if(e.NextInAEL!==s){if(s.isFilled&&s.PrevInAEL.isFilled&&w.slopesEqual(s.PrevInAEL,s,this.isUseFullRange)){const r=y.addOutPt(this.polyOuts,s.PrevInAEL,s.Bot);this.joins.push(new U(n,r,s.Top))}let i=e.NextInAEL;if(i!==null)for(;i!==s;)this.intersectEdges(s,i,e.Curr,!1),i=i.NextInAEL}}}processIntersections(t,e){if(this.activeEdges===null)return!0;try{if(this.buildIntersectList(t,e),this.intersections.length===0)return!0;if(this.intersections.length===1||this.fixupIntersectionOrder())this.processIntersectList();else return!1}catch{this.sortedEdges=null,this.intersections.length=0,Y("ProcessIntersections error")}return this.sortedEdges=null,!0}processIntersectList(){const t=this.intersections.length;let e=0,s=null;for(e=0;e<t;++e)s=this.intersections[e],this.intersectEdges(s.Edge1,s.Edge2,s.Pt,!0),this.SwapPositionsInAEL(s.Edge1,s.Edge2);this.intersections=[]}intersectEdges(t,e,s,n){let i=!n&&t.NextInLML===null&&t.Top.almostEqual(s),r=!n&&e.NextInLML===null&&e.Top.almostEqual(s),l=t.isAssigned,a=e.isAssigned;if(t.isWindDeletaEmpty||e.isWindDeletaEmpty){t.isWindDeletaEmpty&&e.isWindDeletaEmpty?(i||r)&&l&&a&&y.addLocalMaxPoly(this.polyOuts,t,e,s,this.activeEdges):t.PolyTyp===e.PolyTyp&&t.WindDelta!==e.WindDelta&&this.clipType===g.UNION?t.isWindDeletaEmpty?a&&(y.addOutPt(this.polyOuts,t,s),l&&t.unassign()):l&&(y.addOutPt(this.polyOuts,e,s),a&&e.unassign()):t.PolyTyp!==e.PolyTyp&&(t.isWindDeletaEmpty&&Math.abs(e.WindCnt)===1&&(this.clipType!==g.UNION||e.WindCnt2===0)?(y.addOutPt(this.polyOuts,t,s),l&&t.unassign()):e.isWindDeletaEmpty&&Math.abs(t.WindCnt)===1&&(this.clipType!==g.UNION||t.WindCnt2===0)&&(y.addOutPt(this.polyOuts,e,s),a&&e.unassign())),i&&(t.isAssigned?Y("Error intersecting polylines"):this.activeEdges=t.deleteFromAEL(this.activeEdges)),r&&(e.isAssigned?Y("Error intersecting polylines"):this.activeEdges=e.deleteFromAEL(this.activeEdges));return}t.PolyTyp===e.PolyTyp?(t.WindCnt=t.WindCnt===-e.WindDelta?-t.WindCnt:t.WindCnt+e.WindDelta,e.WindCnt=e.WindCnt===t.WindDelta?-e.WindCnt:e.WindCnt-t.WindDelta):(t.WindCnt2+=e.WindDelta,e.WindCnt2-=t.WindDelta);let u=0,h=0;switch(this.fillType){case q.POSITIVE:u=t.WindCnt,h=e.WindCnt;break;case q.NEGATIVE:u=-t.WindCnt,h=-e.WindCnt;break;default:u=Math.abs(t.WindCnt),h=Math.abs(e.WindCnt);break}if(l&&a)i||r||u!==0&&u!==1||h!==0&&h!==1||t.PolyTyp!==e.PolyTyp?y.addLocalMaxPoly(this.polyOuts,t,e,s,this.activeEdges):(y.addOutPt(this.polyOuts,t,s),y.addOutPt(this.polyOuts,e,s),w.swapSides(t,e),w.swapPolyIndexes(t,e));else if(l)(h===0||h===1)&&(y.addOutPt(this.polyOuts,t,s),w.swapSides(t,e),w.swapPolyIndexes(t,e));else if(a)(u===0||u===1)&&(y.addOutPt(this.polyOuts,e,s),w.swapSides(t,e),w.swapPolyIndexes(t,e));else if((u===0||u===1)&&(h===0||h===1)&&!i&&!r){let c=0,x=0;switch(this.fillType){case q.POSITIVE:c=t.WindCnt2,x=e.WindCnt2;break;case q.NEGATIVE:c=-t.WindCnt2,x=-e.WindCnt2;break;default:c=Math.abs(t.WindCnt2),x=Math.abs(e.WindCnt2);break}if(t.PolyTyp!==e.PolyTyp)this.AddLocalMinPoly(t,e,s);else if(u===1&&h===1)switch(this.clipType){case g.UNION:c<=0&&x<=0&&this.AddLocalMinPoly(t,e,s);break;case g.DIFFERENCE:(t.PolyTyp===j.CLIP&&Math.min(c,x)>0||t.PolyTyp===j.SUBJECT&&Math.max(c,x)<=0)&&this.AddLocalMinPoly(t,e,s);break}else w.swapSides(t,e)}i!==r&&(i&&t.isAssigned||r&&e.isAssigned)&&(w.swapSides(t,e),w.swapPolyIndexes(t,e)),i&&(this.activeEdges=t.deleteFromAEL(this.activeEdges)),r&&(this.activeEdges=e.deleteFromAEL(this.activeEdges))}AddLocalMinPoly(t,e,s){let n=null,i=null,r;if(e.isHorizontal||t.Dx>e.Dx?(n=y.addOutPt(this.polyOuts,t,s),e.index=t.index,e.Side=A.RIGHT,t.Side=A.LEFT,i=t,r=i.PrevInAEL===e?e.PrevInAEL:i.PrevInAEL):(n=y.addOutPt(this.polyOuts,e,s),t.index=e.index,t.Side=A.RIGHT,e.Side=A.LEFT,i=e,r=i.PrevInAEL===t?t.PrevInAEL:i.PrevInAEL),r!==null&&r.isFilled&&r.topX(s.y)===i.topX(s.y)&&w.slopesEqual(i,r,this.isUseFullRange)&&!i.isWindDeletaEmpty){const l=y.addOutPt(this.polyOuts,r,s);this.joins.push(new U(n,l,i.Top))}return n}buildResult(t){const e=this.polyOuts.length;let s=null,n=null,i=0;for(i=0;i<e;++i)s=this.polyOuts[i],n=s.export(),n!==null&&t.push(n)}reset(){super.reset(),this.scanbeam=this.minimaList!==null?this.minimaList.getScanbeam():null,this.activeEdges=null,this.sortedEdges=null}popScanbeam(){const t=this.scanbeam.Y;return this.scanbeam=this.scanbeam.Next,t}disposeAllPolyPts(){const t=this.polyOuts.length;let e=null,s=0;for(s=0;s<t;++s)e=this.polyOuts[s],e.dispose();this.polyOuts=[]}processHorizontals(t){let e=this.sortedEdges;for(;e!==null;)this.sortedEdges=e.deleteFromSEL(this.sortedEdges),this.processHorizontal(e,t),e=this.sortedEdges}processHorizontal(t,e){let s=t.horzDirection,n=s[0],i=s[1],r=s[2],l=t,a=null;for(;l.NextInLML!==null&&l.NextInLML.isHorizontal;)l=l.NextInLML;for(l.NextInLML===null&&(a=l.maximaPair);;){const u=t===l;let h=t.getNextInAEL(n),c=null;for(;h!==null&&!(h.Curr.x===t.Top.x&&t.NextInLML!==null&&h.Dx<t.NextInLML.Dx);){if(c=h.getNextInAEL(n),n===A.RIGHT&&h.Curr.x<=r||n===A.LEFT&&h.Curr.x>=i){if(t.isFilled&&this.prepareHorzJoins(t,e),h===a&&u){n===A.RIGHT?this.intersectEdges(t,h,h.Top,!1):this.intersectEdges(h,t,h.Top,!1),a.isAssigned&&Y("ProcessHorizontal error");return}const x=p.create(h.Curr.x,t.Curr.y);n===A.RIGHT?this.intersectEdges(t,h,x,!0):this.intersectEdges(h,t,x,!0),this.SwapPositionsInAEL(t,h)}else if(n===A.RIGHT&&h.Curr.x>=r||n===A.LEFT&&h.Curr.x<=i)break;h=c}if(t.isFilled&&this.prepareHorzJoins(t,e),t.NextInLML!==null&&t.NextInLML.isHorizontal)t=this.updateEdgeIntoAEL(t),t.isAssigned&&y.addOutPt(this.polyOuts,t,t.Bot),s=t.horzDirection,n=s[0],i=s[1],r=s[2];else break}if(t.NextInLML!==null)if(t.isAssigned){const u=y.addOutPt(this.polyOuts,t,t.Top);if(t=this.updateEdgeIntoAEL(t),t.isWindDeletaEmpty)return;let h=t.PrevInAEL,c=t.NextInAEL;if(h!==null&&h.Curr.almostEqual(t.Bot)&&h.isFilled&&h.Curr.y>h.Top.y&&w.slopesEqual(t,h,this.isUseFullRange)){const x=y.addOutPt(this.polyOuts,h,t.Bot);this.joins.push(new U(u,x,t.Top))}else if(c!==null&&c.Curr.almostEqual(t.Bot)&&c.isFilled&&c.Curr.y>c.Top.y&&w.slopesEqual(t,c,this.isUseFullRange)){const x=y.addOutPt(this.polyOuts,c,t.Bot);this.joins.push(new U(u,x,t.Top))}}else t=this.updateEdgeIntoAEL(t);else a!==null?a.isAssigned?(n===A.RIGHT?this.intersectEdges(t,a,t.Top,!1):this.intersectEdges(a,t,t.Top,!1),a.isAssigned&&Y("ProcessHorizontal error")):(this.activeEdges=t.deleteFromAEL(this.activeEdges),this.activeEdges=a.deleteFromAEL(this.activeEdges)):(t.isAssigned&&y.addOutPt(this.polyOuts,t,t.Top),this.activeEdges=t.deleteFromAEL(this.activeEdges))}prepareHorzJoins(t,e){if(e){let s=this.polyOuts[t.index].Pts;t.Side===A.RIGHT&&(s=s.prev);const n=s.point.almostEqual(t.Top)?t.Bot:t.Top;this.ghostJoins.push(new U(s,null,n))}}updateEdgeIntoAEL(t){t.NextInLML===null&&Y("UpdateEdgeIntoAEL: invalid call");const e=t.PrevInAEL,s=t.NextInAEL;return t.NextInLML.index=t.index,e!==null?e.NextInAEL=t.NextInLML:this.activeEdges=t.NextInLML,s!==null&&(s.PrevInAEL=t.NextInLML),t.NextInLML.Side=t.Side,t.NextInLML.WindDelta=t.WindDelta,t.NextInLML.WindCnt=t.WindCnt,t.NextInLML.WindCnt2=t.WindCnt2,t=t.NextInLML,t.Curr.update(t.Bot),t.PrevInAEL=e,t.NextInAEL=s,t.isHorizontal||(this.scanbeam=J.insert(t.Top.y,this.scanbeam)),t}doSimplePolygons(){let t=0,e=null,s=null;for(;t<this.polyOuts.length;)s=this.polyOuts[t++],e=s.Pts,e!==null&&s.simplify(e,this.polyOuts)}fixupIntersectionOrder(){this.intersections.sort(Rt.sort),this.copyAELToSEL();const t=this.intersections.length;let e=0,s=0,n=null;for(e=0;e<t;++e){if(!this.intersections[e].edgesAdjacent){for(s=e+1;s<t&&!this.intersections[s].edgesAdjacent;)++s;if(s===t)return!1;n=this.intersections[e],this.intersections[e]=this.intersections[s],this.intersections[s]=n}this.SwapPositionsInSEL(this.intersections[e].Edge1,this.intersections[e].Edge2)}return!0}SwapPositionsInAEL(t,e){w.swapPositionsInAEL(t,e)&&(t.PrevInAEL===null?this.activeEdges=t:e.PrevInAEL===null&&(this.activeEdges=e))}SwapPositionsInSEL(t,e){w.swapPositionsInSEL(t,e)&&(t.PrevInSEL===null?this.sortedEdges=t:e.PrevInSEL===null&&(this.sortedEdges=e))}copyAELToSEL(){let t=this.activeEdges;for(this.sortedEdges=t;t!==null;)t=t.copyAELToSEL()}buildIntersectList(t,e){if(this.activeEdges===null)return;let s=this.activeEdges;for(this.sortedEdges=s;s!==null;)s.PrevInSEL=s.PrevInAEL,s.NextInSEL=s.NextInAEL,s.Curr.x=s.topX(e),s=s.NextInAEL;let n=!0,i=null,r=null;for(;n&&this.sortedEdges!==null;){for(n=!1,s=this.sortedEdges;s.NextInSEL!==null;)i=s.NextInSEL,r=p.zero(),s.Curr.x>i.Curr.x?(!w.intersectPoint(s,i,r,this.isUseFullRange)&&s.Curr.x>i.Curr.x+1&&Y("Intersection error"),r.y>t&&r.set(Math.abs(s.Dx)>Math.abs(i.Dx)?i.topX(t):s.topX(t),t),this.intersections.push(new Rt(s,i,r)),this.SwapPositionsInSEL(s,i),n=!0):s=i;if(s.PrevInSEL!==null)s.PrevInSEL.NextInSEL=null;else break}this.sortedEdges=null}}class rt{constructor(){this.srcPolygon=[]}execute(t,e){this.srcPolygon=this.formatPath(t);const s=[],n=this.doOffset(e),i=new ft;if(i.addPath(n,j.SUBJECT),e>0)i.execute(g.UNION,s,q.POSITIVE);else{const r=rt.getOuterBounds(n);i.addPath(r,j.SUBJECT),i.ReverseSolution=!0,i.execute(g.UNION,s,q.NEGATIVE),s.length>0&&s.splice(0,1)}return s}formatPath(t){let e=t.length-1,s=0,n=0;for(;e>0&&t[0].almostEqual(t[e]);)--e;const i=[];for(i.push(t[0]),s=1;s<=e;++s)i[n].almostEqual(t[s])||(++n,i.push(t[s]));return n>=2&&Wt(i)<0&&i.reverse(),i}doOffset(t){const e=this.srcPolygon.length,s=[];let n=0;if(e==1){const i=p.create(-1,-1);for(n=0;n<4;++n)s.push(p.from(i).scaleUp(t).add(this.srcPolygon[0])),i.x<0?i.x=1:i.y<0?i.y=1:i.x=-1}else{const i=new Array(e);for(n=0;n<e;++n)i[n]=p.from(this.srcPolygon[O(n,this.srcPolygon.length,1)]).sub(this.srcPolygon[n]).normal().normalize();let r=e-1;for(n=0;n<e;++n)r=this.offsetPoint(s,i,t,n,r)}return s}offsetPoint(t,e,s,n,i){let r=e[n].cross(e[i]);if(Math.abs(r)<5e-5)return i;r>1?r=1:r<-1&&(r=-1);const l=this.srcPolygon[n],a=e[n],u=e[i];if(r*s<0)t.push(p.from(u).scaleUp(s).add(l).clipperRound()),t.push(p.from(l)),t.push(p.from(a).scaleUp(s).add(l).clipperRound());else{const h=1+a.dot(u);if(h>=1.8){const c=s/h;t.push(p.from(u).add(a).scaleUp(c).add(l).clipperRound())}else{const c=Math.tan(Math.atan2(r,u.dot(a))*.25);t.push(p.from(u).normal().scaleUp(c).reverse().add(u).scaleUp(s).add(l)),t.push(p.from(a).normal().scaleUp(c).add(a).scaleUp(s).add(l))}}return n}static getOuterBounds(t){const e=t.length;let s=t[0].x,n=t[0].x,i=t[0].y,r=t[0].y,l=null,a=0;for(a=0;a<e;++a)l=t[a],s=Math.min(l.x,s),n=Math.max(l.x,n),i=Math.min(l.y,i),r=Math.max(l.y,r);return[p.create(s-10,r+10),p.create(n+10,r+10),p.create(n+10,i-10),p.create(s-10,i-10)]}static create(){return new rt}}class St{constructor(t=0,e=0,s=0,n=0){this._memSeg=new Float64Array([t,e,s,n]),this._position=new p(this._memSeg,0),this._size=new p(this._memSeg,2)}clone(){return new St(this._position.x,this._position.y,this._size.x,this._size.y)}update(t,e){this._position.update(t),this._size.update(e)}get position(){return this._position}get size(){return this._size}get x(){return this._position.x}get y(){return this._position.y}get width(){return this._size.x}get height(){return this._size.y}}class Z{constructor(){this.point=p.zero(),this.closed=!1,this.pointCount=0,this.offset=0,this.rectangle=!1,this.bounds=new St}bind(t,e=0,s=t.length>>1){this.closedDirty=!1,this.rectangle=!1,this.closed=!1,this.pointCount=0,this.offset=0,this.pointCount=s,this.offset=e,this.memSeg=t,this.calculateBounds()}bindNFP(t,e){const s=t[nt+e],n=et(s,1),i=et(s,0)>>>1;this.bind(t,n,i)}clean(){this.closedDirty=!1,this.rectangle=!1,this.closed=!1,this.pointCount=0,this.offset=0,this.memSeg=null,this.point.bind(null)}rotate(t){const e=this.pointCount;let s=0;for(s=0;s<e;++s)this.at(s).rotate(t);this.calculateBounds()}at(t){if(t>=this.length)return null;const e=O(t,this.pointCount,0);return this.point.bind(this.memSeg,this.getPointOffset(e))}pointIn(t,e=null){if(this.isBroken)return null;const s=p.from(t),n=p.zero(),i=p.zero(),r=this.pointCount;let l=!1,a=0;for(a=0;a<r;++a){if(n.update(this.at(a)),i.update(this.at(O(a,r,-1))),e!==null&&(n.add(e),i.add(e)),n.almostEqual(s)||s.onSegment(n,i))return null;n.almostEqual(i)||n.y>s.y!=i.y>s.y&&s.x<s.interpolateX(i,n)&&(l=!l)}return l}close(){this.isClosed||(this.closedDirty=!0)}reverse(){const t=this.pointCount>>1,e=this.pointCount-1;let s=0,n=0,i=0,r=0,l=0,a=0;for(s=0;s<t;++s)n=e-s,i=this.offset+(s<<1),r=this.offset+(n<<1),l=this.offset+i+1,a=this.offset+r+1,this.memSeg[i]=this.memSeg[i]+this.memSeg[r],this.memSeg[r]=this.memSeg[i]-this.memSeg[r],this.memSeg[i]=this.memSeg[i]-this.memSeg[r],this.memSeg[l]=this.memSeg[l]+this.memSeg[a],this.memSeg[a]=this.memSeg[l]-this.memSeg[a],this.memSeg[l]=this.memSeg[l]-this.memSeg[a]}exportBounds(){return this.bounds.clone()}resetPosition(){const t=p.from(this.position),e=this.length;let s=0;for(s=0;s<e;++s)this.at(s).sub(t);this.calculateBounds()}normalize(){let t=this.pointCount;const e=p.from(this.first),s=p.from(this.last);for(;e.almostEqual(s);)--t,s.update(this.at(t-1));return this.pointCount!==t&&(this.pointCount=t,this.memSeg=this.memSeg.slice(this.offset,this.offset+(t<<1))),this.area>0&&this.reverse(),this.memSeg}getPointOffset(t){return this.offset+(t<<1)}calculateBounds(){if(this.isBroken)return;const t=p.from(this.first),e=p.from(this.last);this.closed=t.almostEqual(e);const s=this.pointCount;let n=0,i=null;for(n=0;n<s;++n)i=this.at(n),t.min(i),e.max(i);for(this.rectangle=!0,n=0;n<this.pointCount;++n)if(i=this.at(n),!((N(i.x,t.x)||N(i.x,e.x))&&(N(i.y,t.y)||N(i.y,e.y)))){this.rectangle=!1;break}e.sub(t),this.bounds.update(t,e)}get length(){const t=this.closedDirty?1:0;return this.pointCount+t}get first(){return this.at(0)}get last(){return this.at(O(this.length,this.pointCount,-1))}get isBroken(){return this.length<3}get isClosed(){return this.closed||this.closedDirty}get isRectangle(){return this.rectangle}get area(){const t=this.pointCount,e=p.zero(),s=p.zero();let n=0,i=0;for(i=0;i<t;++i)e.update(this.at(O(i,t,-1))),s.update(this.at(i)),n+=(e.x+s.x)*(e.y-s.y);return .5*n}get absArea(){return Math.abs(this.area)}get position(){return this.bounds.position}get size(){return this.bounds.size}static create(){return new Z}static fromMemSeg(t){const e=new Z;return e.bind(t),e}}const P=class P{constructor(t){this.configuration=t,this.polygon=Z.create()}generateBounds(t){if(this.polygon.bind(t),this.polygon.isBroken)return null;const e=Lt(-1,t),s=this.polygon.exportBounds(),n=rt.create();this.cleanNode(e),this.offsetNode(n,e,-1),this.polygon.bind(e.memSeg),this.polygon.resetPosition();const i=this.polygon.exportBounds(),r=this.polygon.area;return{binNode:e,bounds:s,resultBounds:i,area:r}}generateTree(t,e){const s=p.zero(),{curveTolerance:n}=this.configuration,i=n*n,r=[],l=t.length;let a=null,u=null,h=0;for(h=0;h<l;++h){if(a=t[h],u=Lt(h,a),this.cleanNode(u),this.polygon.bind(u.memSeg),this.polygon.isBroken||this.polygon.absArea<=i){console.warn("Can not parse polygon",h);continue}r.push(u)}e&&this.nestPolygons(s,r);const c=rt.create();return this.offsetNodes(c,r,1),r}nestPolygons(t,e){const s=[];let n=0,i=0,r=e.length,l=null,a=null,u=!1;for(n=0;n<r;++n){for(l=e[n],u=!1,t.fromMemSeg(l.memSeg),i=0;i<r;++i)if(a=e[i],this.polygon.bind(a.memSeg),i!==n&&this.polygon.pointIn(t)){a.children.push(l),u=!0;break}u||s.push(l)}for(n=0;n<r;++n)s.indexOf(e[n])<0&&(e.splice(n,1),--r,--n);const h=s.length;let c=null;for(n=0;n<h;++n)c=s[n],c.children&&this.nestPolygons(t,c.children)}offsetNodes(t,e,s){const n=e.length;let i=null,r=0;for(r=0;r<n;++r)i=e[r],this.offsetNode(t,i,s),this.offsetNodes(t,i.children,-s)}offsetNode(t,e,s){if(this.configuration.spacing!==0){const{spacing:n}=this.configuration,i=.5*n*s,r=P.fromMemSeg(e.memSeg),l=t.execute(r,i*P.CLIPPER_SCALE);if(l.length!==1)throw new Error(`Error while offset ${JSON.stringify(e)}`);e.memSeg=P.toMemSeg(l[0]),this.cleanNode(e)}this.polygon.bind(e.memSeg),e.memSeg=this.polygon.normalize()}cleanNode(t){const{curveTolerance:e}=this.configuration,s=P.fromMemSeg(t.memSeg),n=[],i=new ft;if(i.StrictlySimple=!0,i.addPath(s,j.SUBJECT),i.execute(g.UNION,n,q.NON_ZERO),!n||n.length===0)return;let r=0,l=n[0],a=ct(l),u=0,h=n.length;for(r=1;r<h;++r)u=ct(n[r]),u>a&&(l=n[r],a=u);const c=At(l,e*P.CLIPPER_SCALE);h=c&&c.length?c.length:0,h&&(t.memSeg=P.toMemSeg(c))}static fromNfp(t,e,s=null){const n=s===null?-1:P.CLEAN_TRASHOLD,i=s===null,r=t[nt+e],l=et(r,1),a=et(r,0)>>>1;return P.fromMemSeg(t,l,a,1,s,i,n)}static fromMemSeg(t,e=0,s=t.length>>1,n=1,i=null,r=!1,l=-1){const a=n*P.CLIPPER_SCALE,u=[],h=p.zero();let c=0;for(c=0;c<s;++c)h.fromMemSeg(t,c,e),i!==null&&h.add(i),h.scaleUp(a),r&&h.round(),u.push(p.from(h));return l!==-1?At(u,l):u}static toMemSeg(t,e=null,s=null){const n=t.length,i=e||new Float64Array(n<<1),r=p.zero();let l=0;for(l=0;l<n;++l)r.fromClipper(t[l]).scaleDown(P.CLIPPER_SCALE),s!==null&&r.add(s),r.fill(i,l);return i}static applyNfps(t,e,s){const n=new Float64Array(e),i=n[1];let r=null,l=0;for(l=0;l<i;++l)r=P.fromNfp(n,l,s),ct(r)>P.AREA_TRASHOLD&&t.addPath(r,j.SUBJECT)}static nfpToClipper(t,e){const s=t.alloc(1),n=e[1];let i=0;const r=[];for(i=0;i<n;++i)r.push(P.fromNfp(e,i));return t.malloc(s),r}static getFinalNfps(t,e,s,n,i,r){const l=t.alloc(1),a=t.get(l,0);let u=new ft,h=0,c=0;for(h=0;h<s.length;++h)c=Nt(e.rotations,!1,s[h],n),e.nfpCache.has(c)&&(a.fromMemSeg(r,h),P.applyNfps(u,e.nfpCache.get(c),a));t.malloc(l);const x=[];if(!u.execute(g.UNION,x,q.NON_ZERO))return null;let f=[];const E=P.nfpToClipper(t,i);if(u=new ft,u.addPaths(x,j.CLIP),u.addPaths(E,j.SUBJECT),!u.execute(g.DIFFERENCE,f,q.NON_ZERO))return null;for(f=$t(f,P.CLEAN_TRASHOLD),h=0;h<f.length;++h)ct(f[h])<P.AREA_TRASHOLD&&(f.splice(h,1),--h);return f.length===0?null:f}};P.CLIPPER_SCALE=1e7,P.AREA_TRASHOLD=.1*P.CLIPPER_SCALE*P.CLIPPER_SCALE,P.CLEAN_TRASHOLD=1e-4*P.CLIPPER_SCALE;let xt=P;const K=class K{constructor(t){this.items=new Array(K.POOL_SIZE),this.used=0,this.memSeg=new Float64Array(t,0,K.POOL_SIZE<<1),this.memSeg.fill(0);for(let e=0;e<K.POOL_SIZE;++e)this.items[e]=new p(this.memSeg,e<<1)}alloc(t){let e=0,s=0,n=~this.used,i=0;for(;n!==0;)if(i=1<<K.MAX_BITS-Math.clz32(n),e|=i,n&=~i,++s,s===t)return this.used|=e,e;throw Error("Pool is empty")}malloc(t){this.used&=~t}get(t,e){let s=0,n=0,i=0,r=t;for(;r!==0;){if(n=K.MAX_BITS-Math.clz32(r),i=1<<n,s===e)return this.items[n];r&=~i,++s}throw Error(`Can't find point with index ${e}`)}get size(){return this.memSeg.byteLength}};K.MAX_BITS=31,K.POOL_SIZE=32;let Pt=K;var qt=(o=>(o[o.PLACEMENT=1]="PLACEMENT",o[o.PAIR=0]="PAIR",o))(qt||{});const lt=3;function Yt(o,t,e,s){const[n,i,r]=p.lineEquation(o,t),[l,a,u]=p.lineEquation(e,s),h=n*a-l*i,c=(i*u-a*r)/h,x=(l*r-n*u)/h;return!(!(isFinite(c)&&isFinite(x))||!N(o.x,t.x)&&V(c,o.x,t.x)>0||!N(o.y,t.y)&&V(x,o.y,t.y)>0||!N(e.x,s.x)&&V(c,e.x,s.x)>0||!N(e.y,s.y)&&V(x,e.y,s.y)>0)}function pt(o,t,e,s){const n=t.length;let i=O(e,n,s);o.update(t.at(e)),o.almostEqual(t.at(i))&&(i=O(i,n,s),o.update(t.at(i)))}function Et(o,t,e,s,n,i,r,l){return{point:o,polygon:t,segmentStart:e,segmentEnd:s,checkStart:n,checkEnd:i,target:r,offset:l}}function te({point:o,segmentStart:t,segmentEnd:e,target:s,polygon:n,checkStart:i,checkEnd:r,offset:l}){if(o.onSegment(t,e)||o.almostEqual(s)){const a=n.pointIn(i,l),u=n.pointIn(r,l);return a!==null&&u!==null&&a!==u}return null}function zt(o,t,e,s){const n=o.alloc(9),i=o.get(n,0),r=o.get(n,1),l=o.get(n,2),a=o.get(n,3),u=o.get(n,4),h=o.get(n,5),c=o.get(n,6),x=o.get(n,7),f=o.get(n,8).set(0,0),E=t.length,d=e.length,m=[Et(h,t,r,l,u,c,r,s),Et(c,t,r,l,h,x,l,s),Et(r,e,h,c,i,l,c,f),Et(l,e,h,c,r,a,r,f)],L=m.length;let I=0,v=0,S=0,T=!1;for(I=0;I<E-1;++I)for(r.update(t.at(I)),l.update(t.at(I+1)),pt(i,t,I,-1),pt(a,t,I+1,1),v=0;v<d-1;++v){for(h.update(e.at(v)),c.update(e.at(v+1)),pt(u,e,v,-1),pt(x,e,v+1,1),u.add(s),h.add(s),x.add(s),c.add(s),T=null,S=0;S<L&&(T=te(m[S]),T===null);++S);if(T||T===null&&Yt(h,c,r,l))return o.malloc(n),!0;if(T===!1)continue}return o.malloc(n),!1}function Ct(o,t,e,s,n,i=!1){const r=o.alloc(2),l=o.get(r,0).update(n).normalize(),a=o.get(r,1).update(l).normal(),u=a.dot(t),h=a.dot(e),c=a.dot(s),x=l.dot(t),f=l.dot(e),E=l.dot(s);if(!i){if(V(u,h,c)>X)return o.malloc(r),NaN;if(N(u,h)&&N(u,c)&&V(x,f,E)>0)return o.malloc(r),x-Math.max(f,E)}return o.malloc(r),f-x-(f-E)*(h-u)/(h-c)}function dt(o,t,e,s,n,i,r,l,a){const u=r.dot(t),h=r.dot(s),c=r.dot(n);if(V(u,h,c)>=0)return a;const x=Ct(o,t,s,n,i);if(Number.isNaN(x))return a;if(N(x)){const f=Ct(o,e,s,n,i,!0);if(f<0||N(f*l))return a}return Number.isNaN(a)?x:Math.min(x,a)}function ee(o,t,e,s,n,i){let r=o.alloc(3);const l=o.get(r,0).update(i).normal(),a=o.get(r,1).update(i).reverse(),u=o.get(r,2).update(i),h=l.dot(t),c=l.dot(e),x=l.dot(s),f=l.dot(n),E=u.dot(t),d=u.dot(e),m=u.dot(s),L=u.dot(n),I=Math.min(h,c),v=Math.max(h,c),S=Math.max(x,f),T=Math.min(x,f);if(v-T<X||S-I<X)return o.malloc(r),NaN;const M=v>S&&I<T||S>v&&T<I?1:(Math.min(v,S)-Math.max(I,T))/(Math.max(v,S)-Math.min(I,T)),B=o.alloc(3),z=o.get(B,0).update(e).sub(t),F=o.get(B,1).update(s).sub(t),W=o.get(B,2).update(n).sub(t),H=F.cross(z),_=W.cross(z);if(r|=B,N(H)&&N(_)){const st=o.alloc(2),R=o.get(st,0).update(e).sub(t).normal().normalize(),k=o.get(st,1).update(n).sub(s).normal().normalize();if(r|=st,N(R.cross(k))&&R.dot(k)<0){const G=R.dot(i);if(N(G))return o.malloc(r),NaN;if(G<0)return o.malloc(r),0}return o.malloc(r),NaN}let C=NaN;return N(h,x)?C=E-m:N(h,f)?C=E-L:C=dt(o,t,e,s,n,a,l,M,C),N(c,x)?C=Number.isNaN(C)?d-m:Math.min(d-m,C):N(c,f)?C=Number.isNaN(C)?d-L:Math.min(d-L,C):C=dt(o,e,t,s,n,a,l,M,C),C=dt(o,s,n,t,e,i,l,M,C),C=dt(o,n,s,t,e,i,l,M,C),o.malloc(r),C}function se(o,t,e,s,n){const i=o.alloc(5),r=o.get(i,0),l=o.get(i,1),a=o.get(i,2),u=o.get(i,3),h=o.get(i,4).update(s).normalize(),c=t.length,x=e.length;let f=NaN,E=0,d=0,m=0;for(d=0;d<x;++d)for(a.update(e.at(d)).add(n),u.update(e.at(O(d,x,1))).add(n),m=0;m<c;++m)r.update(t.at(m)),l.update(t.at(O(m,c,1))),!(r.almostEqual(l)||a.almostEqual(u))&&(E=ee(o,r,l,a,u,h),!Number.isNaN(E)&&(Number.isNaN(f)||E<f)&&(E>0||N(E))&&(f=E));return o.malloc(i),f}function Ut(o,t,e,s,n){const i=t.length,r=e.length,l=o.alloc(4),a=o.get(l,0),u=o.get(l,1),h=o.get(l,2),c=o.get(l,3);let x=NaN,f=0,E=0,d=0,m=0;for(E=0;E<r;++E){for(m=NaN,a.update(e.at(E)).add(n),d=0;d<i-1;++d)u.update(t.at(d)),h.update(t.at(O(d,i,1))),c.update(h).sub(u),!N(c.cross(s))&&(f=Ct(o,a,u,h,s),!Number.isNaN(f)&&(Number.isNaN(m)||f<m)&&(m=f));!Number.isNaN(m)&&(Number.isNaN(x)||m>x)&&(x=m)}return o.malloc(l),x}function ne(o,t,e){const s=o.alloc(2),n=o.get(s,0).update(t.position).sub(e.position),i=o.get(s,1).update(t.size).sub(e.size);if(i.x<=0||i.y<=0)return[];n.add(e.first),i.add(n);const r=[new Float64Array([n.x,n.y,i.x,n.y,i.x,i.y,n.x,i.y])];return o.malloc(s),r}function kt(o,t,e){if(e.length===0)return!1;const s=e.length;let n=0,i=0,r=0;for(i=0;i<s;++i)for(o.bind(e[i]),n=o.length,r=0;r<n;++r)if(t.almostEqual(o.at(r)))return!0;return!1}function jt(o,t,e,s,n){const i=o.alloc(1),r=o.get(i,0),l=e.length;let a=0,u=!1;for(a=0;a<l;++a)if(r.update(e.at(a)).add(s),u=t.pointIn(r),u!==null)return o.malloc(i),u;return o.malloc(i),n}function _t(o,t,e,s,n,i,r=[]){e.close(),s.close();const l=e.length,a=s.length,u=o.alloc(3),h=o.get(u,0),c=o.get(u,1),x=o.get(u,2);let f=0,E=0,d=0,m=!1,L=null;for(f=0;f<l-1;++f)if(i.indexOf(f)===-1)for(i.push(f),E=0;E<a;++E){if(h.update(e.at(f)).sub(s.at(O(E,a,0))),m=jt(o,e,s,h,null),m===null)return o.malloc(u),null;if(m===n&&!zt(o,e,s,h)&&!kt(t,h,r))return L=h.export(),o.malloc(u),L;c.update(e.at(O(f,l,1))).sub(e.at(f)),x.update(c).reverse();const I=Ut(o,e,s,c,h),v=Ut(o,s,e,x,h);if(d=-1,!Number.isNaN(I)&&!Number.isNaN(v)?d=Math.min(I,v):Number.isNaN(v)?Number.isNaN(I)||(d=I):d=v,d<X)continue;const S=c.length;if(S-d>=X&&c.scaleUp(d/S),h.add(c),m=jt(o,e,s,h,m),m===n&&!zt(o,e,s,h)&&!kt(t,h,r))return L=h.export(),o.malloc(u),L}return o.malloc(u),null}function tt(o,t,e,s,n,i,r=null){if(t.update(n).sub(i),r!==null&&t.sub(r),!t.isEmpty){const l=o[0]<<1;t.fill(o,l,lt),t.set(e,s),t.fill(o,l+1,lt),o[0]+=1}}function Tt(o,t,e){let s=ht(0,o,0,2);return s=ht(s,t,2,15),ht(s,e,17,15)}function ie(o,t,e,s,n,i,r,l){switch(!0){case e.almostEqual(o):return Tt(0,n,r);case e.onSegment(o,t):return Tt(1,i,r);case o.onSegment(e,s):return Tt(2,n,l);default:return-1}}function re(o,t,e,s,n,i){const r=e.alloc(4),l=e.get(r,0),a=e.get(r,1),u=e.get(r,2),h=e.get(r,3),c=o.length,x=t.length;let f=0,E=0,d=0,m=0,L=0;for(n[0]=0,f=0;f<c;++f)for(d=O(f,c,1),l.update(o.at(f)),a.update(o.at(d)),E=0;E<x;++E)m=O(E,x,1),u.update(t.at(E)).add(s),h.update(t.at(m)).add(s),L=ie(l,a,u,h,f,d,E,m),L!==-1&&(i.push($(L,2,15)),le(o,t,e,s,L,n));e.malloc(r)}function le(o,t,e,s,n,i){const r=$(n,0,2),l=$(n,2,15),a=$(n,17,15),u=o.length,h=t.length,c=O(l,u,-1),x=O(l,u,1),f=O(a,h,-1),E=O(a,h,1),d=e.alloc(7),m=e.get(d,0),L=e.get(d,1),I=e.get(d,2),v=e.get(d,3),S=e.get(d,4),T=e.get(d,5),M=e.get(d,6);switch(m.update(o.at(c)),L.update(o.at(l)),I.update(o.at(x)),v.update(t.at(f)),S.update(t.at(a)),T.update(t.at(E)),r){case 0:{tt(i,M,l,c,m,L),tt(i,M,l,x,I,L),tt(i,M,-1,-1,S,v),tt(i,M,-1,-1,S,T);break}case 1:{tt(i,M,c,l,L,S,s),tt(i,M,l,c,m,S,s);break}default:tt(i,M,-1,-1,L,S,s),tt(i,M,-1,-1,L,v,s)}e.malloc(d)}function oe(o,t,e){const s=o.length>>1;if(s===0)return!1;const n=e.alloc(1),i=e.get(n,0);let r=0;for(r=0;r<s-1;++r)if(i.fromMemSeg(o,r),i.almostEqual(t))return e.malloc(n),!0;return e.malloc(n),!1}function ae(o,t,e,s,n,i){const r=n[0],l=e.alloc(3),a=e.get(l,0),u=e.get(l,1),h=e.get(l,2);let c=-1,x=0,f=0,E=0,d=0;for(d=0;d<r;++d)h.fromMemSeg(n,d<<1,lt),!(!i.isEmpty&&h.dot(i)<0&&(a.update(h).normalize(),u.update(i).normalize(),Math.abs(a.cross(u))<1e-4))&&(f=se(e,o,t,h,s),E=h.length,(Number.isNaN(f)||Math.abs(f)>E)&&(f=E),!Number.isNaN(f)&&f>x&&(x=f,c=d<<1));n[1]=c,n[2]=x,e.malloc(l)}function wt(o,t,e,s,n,i){if(e.isBroken||s.isBroken)return[];const r=[];let l=0,a=e.first.y,u=0,h=s.first.y,c=0;for(l=1;l<e.length;++l)e.at(l).y<a&&(a=e.at(l).y,u=l);for(l=1;l<s.length;++l)s.at(l).y>h&&(h=s.at(l).y,c=l);const x=o.alloc(7),f=o.get(x,0),E=o.get(x,1),d=o.get(x,2),m=o.get(x,3).update(e.at(u)).sub(s.at(c)),L=o.get(x,4),I=o.get(x,5),v=o.get(x,6),S=[],T=e.length,M=s.length,B=10*(T+M);let z=0,F=null,W=null,H=0,_=0,C=0;if(i){if(W=_t(o,t,e,s,!0,r),W===null)return o.malloc(x),S;m.fromMemSeg(W)}for(;;){for(d.update(m),L.set(0,0),f.update(s.first).add(m),E.update(f),F=[f.x,f.y],z=0;z<B;){if(re(e,s,o,d,n,r),ae(e,s,o,d,n,L),C=n[1],H=n[2],C===-1||N(H)){F=null;break}if(I.fromMemSeg(n,C,lt),v.fromMemSeg(n,C+1,lt),L.update(I),H=Math.abs(H),_=I.length,v.x!==-1&&r.push(v.x),v.y!==-1&&r.push(v.y),H<_&&!N(H,_)&&I.scaleUp(H/_),f.add(I),f.almostEqual(E)||oe(F,f,o))break;F.push(f.x),F.push(f.y),d.add(I),++z}if(F&&F.length>0&&S.push(new Float64Array(F)),W=_t(o,t,e,s,i,r,S),W===null)break;m.fromMemSeg(W)}return o.malloc(x),S}function ue(o,t){const e=t.pairContent.init(o);if(e.isBroken)return new Float64Array(0);const{pointPool:s,polygons:n,memSeg:i}=t,r=n[0],l=n[1];r.bind(e.firstNode.memSeg),l.bind(e.secondNode.memSeg);const a=n[2];let u=null,h=0,c=0;if(e.isInside){if(u=r.isRectangle?ne(s,r,l):wt(s,a,r,l,i,!0),h=u.length,h!==0)for(c=0;c<h;++c)a.bind(u[c]),a.area>0&&a.reverse();else e.logError("NFP Warning");return e.getResult(u)}if(u=wt(s,a,r,l,i,!1),u.length===0)return e.logError("NFP Error"),new Float64Array(0);if(a.bind(u[0]),a.absArea<r.absArea)return e.logError("NFP Area Error"),console.log("Area: ",a.absArea),u.splice(c,1),new Float64Array(0);const x=n[3];for(x.bind(u[0]),h=u.length,c=0;c<h;++c)a.bind(u[c]),a.area>0&&a.reverse(),c>0&&x.pointIn(a.first)&&a.area<0&&a.reverse();if(e.isUseHoles){const f=e.firstNode.children.length;let E=null;const d=n[4];for(c=0;c<f;++c)if(E=e.firstNode.children[c],d.bind(E.memSeg),d.size.x>l.size.x&&d.size.y>l.size.y){const m=wt(s,a,d,l,i,!0),L=m?m.length:0;if(L!==0){let I=0;for(I=0;I<L;++I)a.bind(m[I]),a.area<0&&a.reverse(),u.push(m[I])}}}return e.getResult(u)}function Gt(o,t,e,s,n,i){const r=o.alloc(1),l=o.get(r,0),a=e.memSeg.length>>1;let u=0;for(u=0;u<a;++u)l.fromMemSeg(e.memSeg,u).add(s).fill(t,n+u,i);return o.malloc(r),n+a}function he(o,t,e){const s=t.length,n=new Float64Array(s);let i=nt+s,r=0,l=0,a=0;for(a=0;a<s;++a)l=t[a].length,n[a]=It(l,i),i+=l*3;const u=new Float64Array(i);for(u[0]=e,u[1]=s,u.set(n,nt),a=0;a<s;++a)r=et(n[a],1),l=et(n[a],0),u.set(t[a],r),u.set(o[a],r+l);return u}function ce(o,t){const{pointPool:e,polygons:s,memSeg:n}=t,i=t.placeContent.init(o),r=s[0],l=s[1],a=e.alloc(2),u=e.get(a,0),h=e.get(a,1),c=[],x=[];let f=null,E=[],d=[],m=0,L=0,I=0,v=0,S=0,T=0,M=0,B=[],z=null,F=null,W=0,H=0,_=0,C=0,st=0,R=0,k=0,G=0,at=0;for(;i.nodeCount>0;){for(B=[],E=[],d=[],++I,R=0;R<i.nodeCount;++R)if(f=i.nodeAt(R),h.fromMemSeg(f.memSeg),st=i.getPathKey(R),z=i.getBinNfp(R),!(!z||z.length<3||i.getNfpError(B,f))){if(m=NaN,C=z[1],B.length===0){for(k=0;k<C;++k)for(r.bindNFP(z,k),G=0;G<r.length;++G)u.update(r.at(G)).sub(h),(Number.isNaN(m)||u.x<m)&&(m=u.x,L=u.y);d.push(st),E.push(m),E.push(L),B.push(f);continue}if(F=xt.getFinalNfps(e,i,B,f,z,E),F!==null){for(S=0,W=NaN,H=NaN,T=0,k=0;k<F.length;++k)if(_=F[k].length,xt.toMemSeg(F[k],n),r.bind(n,0,_),M=_<<1,!(r.absArea<2))for(G=0;G<_;++G){for(v=0,at=0;at<B.length;++at)u.fromMemSeg(E,at),v=Gt(e,n,B[at],u,v,M);u.update(r.at(G)).sub(h),v=Gt(e,n,f,u,v,M),l.bind(n,M,v),T=l.size.x*2+l.size.y,(Number.isNaN(W)||T<W||N(W,T)&&(Number.isNaN(H)||u.x<H))&&(W=T,S=l.size.x,m=u.x,L=u.y,H=u.x)}Number.isNaN(m)||(B.push(f),d.push(st),E.push(m),E.push(L))}}for(S&&(I+=S/Math.abs(i.area)),R=0;R<B.length;++R)i.removeNode(B[R]);if(E.length===0)break;c.push(E),x.push(d)}return I+=i.nodeCount<<1,e.malloc(a),he(c,x,I)}class ot{constructor(){this._nodes=null}initNodes(t,e){const s=Uint32Array.BYTES_PER_ELEMENT+e,n=new DataView(t),i=n.getUint32(e);this._nodes=new Array(i),ot.deserializeNodes(this._nodes,n,t,s)}clean(){this._nodes=null}nodeAt(t){return this._nodes[t]}removeNode(t){const e=this._nodes.indexOf(t);e!==-1&&this._nodes.splice(e,1)}get isBroken(){return this._nodes.length===0}get nodeCount(){return this._nodes.length}static deserializeNodes(t,e,s,n){const i=t.length;let r=n,l=0,a=0,u=0,h=0,c=null,x=null,f=0;for(f=0;f<i;++f)u=e.getFloat64(r)-1,r+=Float64Array.BYTES_PER_ELEMENT,h=e.getFloat64(r),r+=Float64Array.BYTES_PER_ELEMENT,l=e.getUint32(r)<<1,r+=Uint32Array.BYTES_PER_ELEMENT,c=new Float64Array(s,r,l),r+=c.byteLength,a=e.getUint32(r),r+=Uint32Array.BYTES_PER_ELEMENT,x=new Array(a),r=ot.deserializeNodes(x,e,s,r),t[f]={source:u,rotation:h,memSeg:c,children:x};return r}}class Mt extends ot{constructor(){super(...arguments),this._key=0,this._isInside=!1,this._useHoles=!1}init(t){this.initNodes(t,Float64Array.BYTES_PER_ELEMENT*3);const e=new DataView(t),s=e.getFloat64(Float64Array.BYTES_PER_ELEMENT*2);return this._key=e.getFloat64(Float64Array.BYTES_PER_ELEMENT),this._isInside=Mt.getInside(this._key),this._useHoles=!!$(s,28,1),this}clean(){super.clean(),this._key=0,this._isInside=!1}getResult(t){const e=t.length,s=new Float64Array(e);let n=nt+e,i=0,r=0;for(r=0;r<e;++r)i=t[r].length,s[r]=It(i,n),n+=i;const l=new Float64Array(n);for(l[0]=this._key,l[1]=e,l.set(s,nt),r=0;r<e;++r)l.set(t[r],et(s[r],1));return l}logError(t){console.log(`${t}: `,this._key),console.log("A: ",this.firstNode),console.log("B: ",this.secondNode)}get firstNode(){return this.nodeAt(0)}get secondNode(){return this.nodeAt(1)}get isUseHoles(){return this._useHoles&&this.firstNode.children.length!==0}get isInside(){return this._isInside}static getInside(t){const e=ut[4];return!!$(t,e,1)}}class Ot extends ot{constructor(){super(),this._nfpCache=null,this._area=0,this._rotations=0,this._emptyNode=Lt(-1,new Float64Array(0))}init(t){const e=new DataView(t),s=e.getFloat64(Float64Array.BYTES_PER_ELEMENT*3),n=e.getFloat64(Float64Array.BYTES_PER_ELEMENT);return this.initNodes(t,Float64Array.BYTES_PER_ELEMENT*4+s),this._rotations=$(n,9,5),this._area=e.getFloat64(Float64Array.BYTES_PER_ELEMENT*2),this._nfpCache=Ot.deserializeBufferToMap(t,Float64Array.BYTES_PER_ELEMENT*4,s),this}clean(){super.clean(),this._nfpCache=null,this._area=0}getBinNfp(t){const e=Nt(this.rotations,!0,this._emptyNode,this.nodeAt(t));return this._nfpCache.has(e)?new Float64Array(this._nfpCache.get(e)):null}getNfpError(t,e){const s=t.length;let n=0,i=0;for(n=0;n<s;++n)if(i=Nt(this.rotations,!1,t[n],e),!this._nfpCache.has(i))return!0;return!1}getPathKey(t){return It(yt(this.nodeAt(t).rotation,this.rotations),this.nodeAt(t).source)}get rotations(){return this._rotations}get nfpCache(){return this._nfpCache}get area(){return this._area}static deserializeBufferToMap(t,e,s){const n=new DataView(t),i=new Map,r=e+s;let l=e,a=0,u=0,h=null;for(;l<r;)a=n.getUint32(l),l+=Uint32Array.BYTES_PER_ELEMENT,u=n.getUint32(l),l+=Uint32Array.BYTES_PER_ELEMENT,h=t.slice(l,l+u),l+=u,i.set(a,h);return i}}function fe(o,t){o.isInit||(o.buffer=new ArrayBuffer(8192*Float64Array.BYTES_PER_ELEMENT),o.pointPool=new Pt(o.buffer),o.memSeg=new Float64Array(o.buffer,o.pointPool.size),o.isInit=!0,o.polygons=[Z.create(),Z.create(),Z.create(),Z.create(),Z.create()],o.pairContent=new Mt,o.placeContent=new Ot);const e=o.polygons.length,i=new DataView(t).getFloat64(0)===qt.PAIR,r=i?ue(t,o):ce(t,o);let l=0;for(l=0;l<e;++l)o.polygons[l].clean();return i?o.pairContent.clean():o.placeContent.clean(),r.buffer}const xe={isInit:!1,pointPool:null};self.onmessage=o=>{const t=fe(xe,o.data);self.postMessage(t,[t])}})();
